<!DOCTYPE html>
<html theme="dark">
  <head>
    <base href="/">
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <meta name="HandheldFriendly" content="true">
    <meta name="viewport" content="width=device-width, initial-scale=1,maximum-scale=1,user-scalable=no">
    <title>Jamrock // Fragments</title>
    <meta name="release" content="5273cac">
    <script src="//grown.jamrock.dev/scripts.js"></script>
    <link rel="stylesheet" href="//grown.jamrock.dev/styles.css">
    <link rel="stylesheet" href="//fonts.googleapis.com/css?family=Sorts+Mill+Goudy">
    <style>/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */ /* Tomorrow Comment */ .hljs-comment, .hljs-quote { color: #8e908c; } /* Tomorrow Red */ .hljs-variable, .hljs-template-variable, .hljs-tag, .hljs-name, .hljs-selector-id, .hljs-selector-class, .hljs-regexp, .hljs-deletion { color: #c82829; } /* Tomorrow Orange */ .hljs-number, .hljs-built_in, .hljs-builtin-name, .hljs-literal, .hljs-type, .hljs-params, .hljs-meta, .hljs-link { color: #f5871f; } /* Tomorrow Yellow */ .hljs-attribute { color: #eab700; } /* Tomorrow Green */ .hljs-string, .hljs-symbol, .hljs-bullet, .hljs-addition { color: #718c00; } /* Tomorrow Blue */ .hljs-title, .hljs-section { color: #4271ae; } /* Tomorrow Purple */ .hljs-keyword, .hljs-selector-tag { color: #8959a8; } .hljs { display: block; overflow-x: auto; background: white; color: #4d4d4c; padding: 0.5em; } .hljs-emphasis { font-style: italic; } .hljs-strong { font-weight: bold; }
html[theme=dark] .hljs-comment, html[theme=dark] .hljs-quote { color: #969896; } html[theme=dark] .hljs-variable, html[theme=dark] .hljs-template-variable, html[theme=dark] .hljs-tag, html[theme=dark] .hljs-name, html[theme=dark] .hljs-selector-id, html[theme=dark] .hljs-selector-class, html[theme=dark] .hljs-regexp, html[theme=dark] .hljs-deletion { color: #cc6666; } html[theme=dark] .hljs-number, html[theme=dark] .hljs-built_in, html[theme=dark] .hljs-builtin-name, html[theme=dark] .hljs-literal, html[theme=dark] .hljs-type, html[theme=dark] .hljs-params, html[theme=dark] .hljs-meta, html[theme=dark] .hljs-link { color: #de935f; } html[theme=dark] .hljs-attribute { color: #f0c674; } html[theme=dark] .hljs-string, html[theme=dark] .hljs-symbol, html[theme=dark] .hljs-bullet, html[theme=dark] .hljs-addition { color: #b5bd68; } html[theme=dark] .hljs-title, html[theme=dark] .hljs-section { color: #81a2be; } html[theme=dark] .hljs-keyword, html[theme=dark] .hljs-selector-tag { color: #b294bb; } html[theme=dark] .hljs { display: block; overflow-x: auto; background: #1d1f21; color: #c5c8c6; padding: 0.5em; } html[theme=dark] .hljs-emphasis { font-style: italic; } html[theme=dark] .hljs-strong { font-weight: bold; }

      blockquote b {
        cursor: default;
        font-style: normal;
        margin-right: .2em;
        padding-right: .2em;
        display: inline-block;
        text-align: center;
        width: 1.5em;
      }
      blockquote > pre,
      blockquote > p {
        margin: 0;
      }
      #nav li:last-child {
        flex: 1;
      }
      
    </style>
  </head>
  <body class="reset">
    <script>
      /* eslint-disable */
      (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
      (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
      m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
      })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');
      
      ga('create', '', 'auto');
      ga('send', 'pageview');
      /* eslint-enable */
      
    </script>
    <div id="wrapper">
      <div class="body noscroll" id="content">
        <div class="flex" id="menu">
          <div class="stork-wrapper">
            <pre>File not found: search.svg</pre>
            <input class="stork-input" data-stork="docs" placeholder="Search...">
            <div class="stork-output" data-stork="docs-output"></div>
          </div><a href="/docs/fragments/#nav">&#9776;</a>
        </div>
        <h1>Fragments <small><a href="//github.com/grownjs/jamrock/blob/master/docs/docs/fragments.md" target="_blank">&#9998;</a></small></h1>
        <main><p>Rendering values on the server cannot take forever,
and that was a reason for moving away from this side back in the days...</p>
<p>Today, as we have async/await, generators and iterators, we can do more... a lot more.</p>
<h2 id="consumable-values">Consumable values</h2>
<p>Repeated sections of your template are governed by the <code>{#each}</code> mustache,
it can iterate arrays, objects, even numbers!</p>
<ul>
<li>If <code>5</code> is given, it&#39;ll iterate 5 times.</li>
<li>If <code>[1, 2]</code> is given, it&#39;ll iterate the array.</li>
<li>If <code>{ a: 1, b: 2 }</code> is given, it&#39;ll iterate the object entries.</li>
<li>If a string is given, it&#39;ll iterate its length of times, char by char, etc.</li>
<li>If a promise is given, it&#39;ll be resolved, then consumed as described...</li>
</ul>
<p>If the given value is a generator or an iterator, a <em>stream</em> is allocated: a channel where we put the values from the iteration.</p>
<p>Once a WebSockets connection is established, the client will keep receiving updates as the stream continue yielding values...</p>
<blockquote>
<p><b>⚠</b> The usage of <code>&lt;fragment&gt;</code> may change in future releases, keep an eye out!</p>
</blockquote>
<p>But first, you MUST provide <code>&lt;fragment&gt;...&lt;/fragment&gt;</code> elements on your page to serve as placeholders for updates:</p>
<pre class="hljs"><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">fragment</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;data&quot;</span>&gt;</span>
  {#each data as item}
    {@debug item}
  {/each}
<span class="hljs-tag">&lt;/<span class="hljs-name">fragment</span>&gt;</span>
</code></pre>
<p>This way, we&#39;re telling the compiler where to look and what to render each time we have new <code>data</code>.</p>
<blockquote>
<p><b>⚠</b> The fragment&#39;s <code>key</code> must match the name of the consumed variable, otherwise the target would never match.</p>
</blockquote>
<p>Fragments supports some props for configuration:</p>
<ul>
<li><code>interval</code> &mdash; sets the awaiting time between iterations, in milliseconds.</li>
<li><code>timeout</code> &mdash; waiting period before breaking the iteration on render, default is <code>24</code> ms.</li>
<li><code>mode</code> &mdash; determines how the fragment is patched on the DOM: <code>prepend</code>, <code>append</code> or <code>replace</code>.</li>
</ul>
<h3 id="fixed-updates">Fixed updates</h3>
<p>Once a fragment is declared, we can send updates from our code to the browser with the <code>reply()</code> function, i.e.</p>
<pre class="hljs"><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
  <span class="hljs-keyword">import</span> { reply } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jamrock/conn&#x27;</span>;

  <span class="hljs-keyword">let</span> value;
  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-title function_">reply</span>(<span class="hljs-string">&#x27;target&#x27;</span>, { <span class="hljs-attr">value</span>: <span class="hljs-number">42</span> });
  }, <span class="hljs-number">1000</span>);
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">fragment</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;target&quot;</span>&gt;</span>
    {#if value}
      {@debug value}
    {:else}
      ...
    {/if}
  <span class="hljs-tag">&lt;/<span class="hljs-name">fragment</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>
</code></pre>
<p>In the previous example, we&#39;re just re-rendering the requested fragment with new data, this allow to update other values as well.</p>
<blockquote>
<p><b>⚠</b> Fragments may be wrapped within other HTML tags to prevent leaking nodes.</p>
</blockquote>
<p>To trigger a function, and, in response update a fragment through WebSockets, we MUST use <code>export default</code> methods to declare the callbacks:</p>
<pre class="hljs"><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
  <span class="hljs-keyword">import</span> { reply } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jamrock/conn&#x27;</span>;

  <span class="hljs-keyword">let</span> test;
  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> {
    <span class="hljs-title function_">check</span>(<span class="hljs-params">payload</span>) {
      test = payload.<span class="hljs-property">value</span> || <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>();
      <span class="hljs-title function_">reply</span>(<span class="hljs-string">&#x27;target&#x27;</span>, { test });
    },
  };
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">fragment</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;target&quot;</span>&gt;</span>
    {#if test}
      {@debug test}
    {:else}
      Waiting your input...
    {/if}
  <span class="hljs-tag">&lt;/<span class="hljs-name">fragment</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">form</span> @<span class="hljs-attr">trigger</span>=<span class="hljs-string">&quot;check&quot;</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;value&quot;</span> /&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;submit&quot;</span>&gt;</span>OK<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">form</span>&gt;</span>
</code></pre>
<p>Those callbacks are invoked with user-input through forms, which allow to collect more data if needed.</p>
<blockquote>
<p><b>☞</b> Elements can use events to trigger updates, i.e. <code>&lt;button on:click @trigger=&quot;check&quot;&gt;OK&lt;/button&gt;</code> should work the same way as the form.</p>
</blockquote>
<h3 id="live-updates">Live updates</h3>
<p>We can also send updates over a running stream:</p>
<pre class="hljs"><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">
  <span class="hljs-keyword">import</span> { onRelease } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jamrock/hooks&#x27;</span>;
  <span class="hljs-keyword">import</span> { tick, reply } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jamrock/conn&#x27;</span>;

  <span class="hljs-keyword">let</span> max = <span class="hljs-number">10</span>;
  <span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span>* <span class="hljs-title function_">local</span>(<span class="hljs-params"></span>) {
    <span class="hljs-keyword">yield</span> max;
    <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) {
      <span class="hljs-keyword">if</span> (max &lt;= <span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;
      <span class="hljs-keyword">yield</span> <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>();
      <span class="hljs-keyword">await</span> <span class="hljs-title function_">tick</span>(<span class="hljs-number">200</span>);
    }
  }

  <span class="hljs-keyword">const</span> t = <span class="hljs-built_in">setInterval</span>(<span class="hljs-function">() =&gt;</span> {
    <span class="hljs-keyword">if</span> (max-- &lt;= <span class="hljs-number">0</span>) {
      <span class="hljs-built_in">clearInterval</span>(t);
      <span class="hljs-keyword">return</span>;
    }
    <span class="hljs-title function_">reply</span>({ <span class="hljs-attr">local</span>: max });
  }, <span class="hljs-number">1000</span>);

  <span class="hljs-title function_">onRelease</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-built_in">clearInterval</span>(t));
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">ol</span> <span class="hljs-attr">style:paddingLeft</span>=<span class="hljs-string">&quot;2em&quot;</span> <span class="hljs-attr">reversed</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">fragment</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;local&quot;</span> <span class="hljs-attr">mode</span>=<span class="hljs-string">&quot;prepend&quot;</span>&gt;</span>
    {#each local as item}
      <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>{@debug item}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>
    {/each}
  <span class="hljs-tag">&lt;/<span class="hljs-name">fragment</span>&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ol</span>&gt;</span>
</code></pre>
<p>Here we&#39;re waiting while we yield a new value every 200ms, this will rerender the fragment only and not the whole page.</p>
<blockquote>
<p><b>⚠</b> If the client disconnects all the running iterators shall stop, however, make sure you didn&#39;t left running timers too!</p>
</blockquote>
<h2 id="server-api">Server API</h2>
<p>Fragments are accessible for usage through WebSockets, because that&#39;s the only way</p>
<h2 id="client-api">Client API</h2>
<p>On the client-side, we also provide you with a <code>Fragment</code> class that grants access to manipulate them:</p>
<pre class="hljs"><code class="lang-html"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>
  <span class="hljs-tag">&lt;<span class="hljs-name">fragment</span> <span class="hljs-attr">key</span>=<span class="hljs-string">&quot;local&quot;</span> /&gt;</span>
<span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>

<span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">scoped</span>&gt;</span><span class="language-javascript">
  <span class="hljs-keyword">import</span> { <span class="hljs-title class_">Fragment</span> } <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;jamrock&#x27;</span>;

  <span class="hljs-title class_">Fragment</span>.<span class="hljs-title function_">with</span>(<span class="hljs-string">&#x27;local&#x27;</span>, <span class="hljs-keyword">async</span> frag =&gt; {
    <span class="hljs-keyword">await</span> frag.<span class="hljs-title function_">update</span>([]);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++) {
      frag.<span class="hljs-title function_">append</span>([[<span class="hljs-string">&#x27;li&#x27;</span>, <span class="hljs-literal">null</span>, <span class="hljs-title class_">Math</span>.<span class="hljs-title function_">random</span>()]]);
    }
  });
</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span>
</code></pre>
<p>Normally, you don&#39;t need to access fragments unless you&#39;re integrating advanced stuff, like third-party libraries and such.</p>
<blockquote>
<p><b>⚠</b> This API is unstable and not fully tested yet, it may not work as intended or it may change its behaviour over time.</p>
</blockquote>
<h3 id="props">Props</h3>
<ul>
<li><code>root</code> &mdash; Returns the <code>parentNode</code> of the fragment.</li>
<li><code>length</code> &mdash; The count of <code>childNodes</code> for this fragment.</li>
<li><code>offset</code> &mdash; The actual index from their <code>parentNode.childNodes</code> tree.</li>
<li><code>mounted</code> &mdash; Returns <code>true</code> if the fragment is already mounted on the DOM.</li>
</ul>
<h3 id="methods">Methods</h3>
<ul>
<li><code>prepend(children)</code> &mdash; Insert a list of nodes at the start of the fragment.</li>
<li><code>append(children)</code> &mdash; Insert a list of nodes at the end of the fragment.</li>
<li><code>update(children)</code> &mdash; It calls <code>patch()</code>, returns a promise. It waits until the updates are applied.</li>
<li><code>patch(children)</code> &mdash; Low-level patching method, it does not wait for updates completion!</li>
<li><code>touch(props, children)</code> &mdash; Low-level patching method with <code>props</code> support, it calls <code>patch()</code> afterwards.</li>
<li><code>sync(children, direction)</code> &mdash; Low-level patching method with directional support, it&#39;s used by prepend, append and update methods.</li>
</ul>
<h3 id="static-methods">Static methods</h3>
<ul>
<li><code>from(props[, children[, callback]])</code> &mdash; Low-level fragment mounting, rendering and instatiation: <code>callback</code> can be a render function that returns actual DOM elements.</li>
<li><code>with(key, handler)</code> &mdash; Find and returns the mounted fragment by its <code>key</code> name. The <code>handler</code> can return a function to clear given side-effects.</li>
<li><code>has(key)</code> &mdash; Returns <code>true</code> if the fragment is already registered.</li>
<li><code>for(key)</code> &mdash; Returns the fragment instanced once the DOM is ready, it&#39;s a promise!</li>
<li><code>stop()</code> &mdash; Execute the returned callbacks from the <code>with()</code> calls as cleanup.</li>
</ul>
</main>
        <nav class="flex end gap"><span class="auto">➯ Next: <a id="next" href="docs/stores">Stores</a></span><a id="back" href="/docs/fragments/#" onclick="content.scrollTop=0">&uarr; Back to the top</a>
        </nav>
      </div>
      <aside class="noscroll" id="sidebar">
        <div class="body">
          <h1 class="logotype"><a href=".">
              <pre>File not found: jamrock.svg</pre></a><small>v0.0.0</small></h1>
          <hr>
          <p class="flex">
            <button id="toggle">
              <pre>File not found: bulb.svg</pre>
            </button><small>Reference docs for Jamrock</small>
          </p>
          <hr>
          <div class="flex fit gap push"><a href="//badge.fury.io/js/grown" target="_blank"><img src="//badge.fury.io/js/grown.svg"></a><a href="//codecov.io/gh/grownjs/grown" target="_blank"><img src="//codecov.io/gh/grownjs/grown/branch/master/graph/badge.svg"></a><a href="//github.com/grownjs/grown/actions" target="_blank"><img src="//github.com/grownjs/grown/workflows/build/badge.svg"></a></div>
          <nav id="nav">
            <ul class="reset">
              <li>
                <h3 class="reset">Overview</h3>
                <ul class="reset">
                  <li>
                    <a exact="true" href=".">Introduction</a>
                  </li>
                  <li>
                    <a href="./docs/components">Components</a>
                  </li>
                  <li>
                    <a aria-current="page" href="./docs/fragments">Fragments</a>
                  </li>
                  <li>
                    <a href="./docs/stores">Stores</a>
                  </li>
                </ul>
              </li>
              <li>
                <h3 class="reset">Module</h3>
                <ul class="reset">
                  <li>
                    <a href="./docs/hooks">Hooks</a>
                  </li>
                  <li>
                    <a href="./docs/routes">Routes</a>
                  </li>
                  <li>
                    <a href="./docs/handlers">Handlers</a>
                  </li>
                </ul>
              </li>
              <li>
                <h3 class="reset">State</h3>
                <ul class="reset">
                  <li>
                    <a href="./docs/session">Session</a>
                  </li>
                  <li>
                    <a href="./docs/models">Models</a>
                  </li>
                  <li>
                    <a href="./docs/cache">Cache</a>
                  </li>
                </ul>
              </li>
              <li>
                <h3 class="reset">Context</h3>
                <ul class="reset">
                  <li>
                    <a href="./docs/auth">Auth</a>
                  </li>
                  <li>
                    <a href="./docs/access">Access</a>
                  </li>
                  <li>
                    <a href="./docs/request">Request</a>
                  </li>
                  <li>
                    <a href="./docs/response">Response</a>
                  </li>
                </ul>
              </li>
              <li>
                <h3 class="reset">Utilities</h3>
                <ul class="reset">
                  <li>
                    <a href="./docs/cli">CLI usage</a>
                  </li>
                  <li>
                    <a href="./docs/mailer">Mailer and templates</a>
                  </li>
                  <li>
                    <a href="./docs/uploads">Uploads and static files</a>
                  </li>
                  <li>
                    <a href="./docs/database">Databases and scaffolding</a>
                  </li>
                </ul>
              </li>
            </ul>
          </nav>
        </div>
      </aside>
    </div>
    <script src="//files.stork-search.net/stork.js"></script>
    <script>
      window.stork.register('docs', 'index.st', {
        minimumQueryLength: 2,
      }); // eslint-disable-line
    </script>
  </body>
</html>